{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tool specification","text":""},{"location":"#overview","title":"Overview","text":"<p>This document describes specifications for generic <code>Tool</code> entities. A <code>Tool</code> is: *  any executable software *  contained in a docker (compatible) container  *  transforms <code>Input</code> consisting of optional <code>Parameters</code> and optional <code>Data</code> into output</p> <p>A very simplified workflow of a tool execution looks like the flowchart below:</p> <pre><code>flowchart LR\n    input -- parameters --&gt; container --&gt; output\n    input -- data --&gt; container</code></pre> <p>The main objective is to create a communitiy-driven tool interface specification,  that is language-agnostic and can be implemented a layer below more tool-specific  frameworks, like modeling interfaces. This helps to increase interoperability and reproducibility, especially in a  scientific context.</p> <p>At the same time, the tool specification does not rely upon a metadata-schema,  which is either tool-specific or very generic. But the tool specification can be extended by any metadata schema.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>To contribute to this specification, you can create a Fork  of the repository and adapt as you suggest. Then open a Pull Request and your changes will be reviewed.</p> <p>If you like to review upcoming changes, you can mail @mmaelicke or @AlexDo1 to make you an outside collaborator  of this specification.</p>"},{"location":"#implementations","title":"Implementations","text":"<p>This section lists the implementations, which we are aware of. By implementation,  we are referring to software packages for different programming languages used in either of the tools, that help to parse the parametrization and the input data of a tool into a language specific data structure. Here, you can read more about parameter and data input.</p> <p>The available implementations as of now are:</p> library Language source repository install template repo <code>json2args</code> Python 3.X https://github.com/hydrocode-de/json2args <code>pip install json2args</code> https://github.com/VForWaTer/tool_template_python <code>json2aRgs</code> R &gt; 3.4 https://github.com/VForWaTer/json2aRgs <code>install.packages(\"json2aRgs\")</code> https://github.com/VForWaTer/tool_template_r <code>js2args</code> NodeJS &gt; 14 https://github.com/VForWaTer/js2args <code>npm install js2args</code> https://github.com/vforwater/tool_template_node <code>getParameters.m</code> Octave / MATLAB https://github.com/VForWaTer/tool_template_octave https://github.com/VForWaTer/tool_template_octave <p>The table below lists which implementation exists and what parts of the tool specification are already covered:</p> specification json2args (Python 3.X) json2aRgs (R) getParameters.m (Octave / MATLAB) js2args (Node.js). Parameter Types string integer float enum enum -check values boolean datetime asset Parameter fields array default min &amp; max Data fields extension - <code>.dat</code> extension - <code>.csv</code> extension - <code>.nc</code> extension - <code>.json</code> ======= empty input     * wildcards <p>* <code>empty input</code> refers to the input specification requiring implementations to be able to handle empty or missing <code>/in/input.json</code> by returing an appropriate empty data structure</p>"},{"location":"#frameworks","title":"Frameworks","text":"<p>Frameworks refer to software implementations, that run tools for you. Running tool containers directly by operating the docker/podman CLI is the most low-level option and always possible. The listed solutions will take some of the management boilerplate from you and might turn out useful.</p> <ul> <li><code>toolbox-runner</code> (Python)</li> <li><code>tool-runner-js</code> (NodeJS)</li> </ul>"},{"location":"#contents","title":"Contents","text":"<ul> <li><code>Container</code> structure</li> <li><code>Tool</code> specification</li> <li><code>Input (Parameters and Data)</code> specification</li> </ul>"},{"location":"container/","title":"Container structure","text":""},{"location":"container/#tldr","title":"tl;dr;","text":"<p>In order to be recognized as a tool following this specification, a container  image has to meet these requirements:</p> <ol> <li>A description of the tool, its arguments, parameters and input data has to be present in YAML format at the container location <code>/src/tool.yml</code></li> <li>The executable script/program has to either store results at the location <code>/out/</code> of the container, or print them to the containers StdOut.</li> <li>A tool execution may be parameterized. The parameterization is stored at <code>/in/input.json</code> of the container. Additional input data may be added to <code>/in/input.json</code>.</li> </ol>"},{"location":"container/#description","title":"Description","text":"<p>In order to work properly, there is a minimum required structure, that the  container has to follow. In  order to build a container image accordingly, there are a number of template repositories on Github:</p> <ul> <li>Python template</li> <li>R template</li> <li>Node.js template</li> <li>Octave template</li> <li>MATLAB template</li> </ul> <p>The core idea is to enforce a specific structure in the container, so that  others know where to find things:</p> <pre><code>/\n|- in/\n|  |- input.json\n|- out/\n|  |- ...\n|- src/\n|  |- tool.yml\n|  |- run.[py/R/js/m]\n|  |- CITATION.cff\n</code></pre> <p>Here, the two locations <code>/in</code> and <code>/out</code> are mount points to pass data and  parameters in and out of the container.</p>"},{"location":"container/#input-parameterization","title":"Input parameterization","text":"<p><code>/in/input.json</code> contains the the parameterization for running the tool.  There are client libraries for each of the supported languages, which read and  validate the parameterization. Runtime CLI parameters are not yet supported but are planned for future implementation.</p>"},{"location":"container/#metadata","title":"Metadata","text":"<p><code>/src/tool.yml</code> is a mandatory metadata file containing the most important  information about the tool.</p>"},{"location":"container/#entrypoint","title":"Entrypoint","text":"<p><code>/src/run.[py/R/js/m]</code> is the single entrypoint into the tool.  Any executable file is supported. Please note that the tool-specs support only transformation-like tools that terminate end upon completion;  service tools are not supported.</p> <p>Please note: In order to work properly with external tools, you implement the  execution of the script, as shown in the sample repositories, as the default Docker command, not entrypoint:</p> <pre><code>CMD [\"python\", \"run.py\"]\n</code></pre> <p>This way, you can <code>exec</code> or <code>run</code> into the container and <code>cat /src/tool.yml</code> to build frameworks that can read the metadata of each tool available on the system.</p>"},{"location":"container/#citation-information","title":"Citation information","text":"<p>Each of the template repositories includes a <code>CITATION.cff</code> file, which provides standardized citation metadata for your tool. As a developer, you should replace the placeholder citation information in the template with details relevant to your own project.</p> <p>The <code>CITATION.cff</code> file helps users properly cite your tool/software, increasing its visibility and ensuring you receive appropriate credit. It also aligns your project with FAIR principles by making citation metadata machine-readable and interoperable.</p> <p>GitHub automatically detects this file and displays a \u201cCite this repository\u201d button. When used with services like Zenodo, the metadata from <code>CITATION.cff</code> can be used to generate a DOI with embedded citation information. Other tools such as Zotero also support this format.</p> <p>The <code>CITATION.cff</code> file full format specifications and documentation is described here. To create or edit your file, you can use the online tool:  https://citation-file-format.github.io/cff-initializer-javascript/</p>"},{"location":"input/","title":"Input: Parameter and data definitions","text":"<p>Input of a tool consists of optional <code>Parameters</code> and optional <code>Data</code>.</p> <p>We define a <code>Parameter</code> to be a structured argument, which is passed to a  Tool on runtime. The sum of all passed <code>Parameters</code> make up the  parameterization or parametrization of a tool execution.</p> <p>All tools define their <code>Parameters</code> and <code>Data</code> in the <code>tool.yml</code>. This is the  blueprint about the parameter values and input data that are acceptable or  required along with specifications, e.g. about value ranges, default values and data types. The actual definition of input (parameterization and input data)  when running a tool is file based and defaults to <code>/in/input.json</code>. The JSON  format is mandatory. </p>"},{"location":"input/#missing-parameterization-and-input-data","title":"Missing parameterization and input data","text":"<p>In case a Tool accepts only optional parameters and no input data, or no parameters and no data are defined at all, the <code>/in/input.json</code> can be  an empty file:</p> <pre><code>{}\n</code></pre> <p>This is the only case, in which this file is optional and can be omitted entirely. Libraries parsing the parameters or tools, which read the file directly need to reflect this behavior and return an empty container. The exact data type of an empty parameterization container depends on the implementation language. In Python this would be an empty <code>dict</code>, in R an empty <code>list</code>.</p>"},{"location":"input/#parameterization-vs-data","title":"Parameterization vs. Data","text":"<p>In the semantics of Tools, there is a difference between data, which  is processed by a tool and parameters, which configure a tool. On the one hand this differentiation is important to reflect the meaning of  arguments passed to generic tools, on the other hand there are implications for reproducible workflows.</p> <p>Changing the parameters of the tool results in a different analysis workflow, as a change in parameters might in principle change the logic. Hence, a different  parameterization describes a different analysis.  Changing data does not change the tool logic. By definition, a tool is reproducible, if the parameterization of a tool can be applied to other data. That means, the  same analysis is run on different data.</p> <p>From a practical perspective, if you build a tool around these tool specifications, the tool name and content of the sections <code>parameters</code> and <code>data</code> of <code>/in/input.json</code>  can be used to create checksums and therefore help to establish reproducible workflows.</p>"},{"location":"input/#parameters-file-specification","title":"Parameters: File specification","text":"<p>Each <code>Parameter</code> is described in a parameter block in the <code>/src/tool.yml</code> file. All parameters are collected as the mandatory <code>tools.&lt;tool_name&gt;.parameters</code> block:</p> <pre><code>tools:\n  foobar:\n    parameters:\n      foo_parameter:\n        [...]\n</code></pre> <p>Refer to the section below to learn about mandatory and optional fields for a <code>Parameter</code>.</p>"},{"location":"input/#fields","title":"Fields","text":"<p>The following section defines all mandatory and optional fields of a <code>Parameter</code> entity.</p>"},{"location":"input/#type","title":"<code>type</code>","text":"<p>The <code>type</code> field is the only mandatory field. Each parameter needs a data-type. Allowed data-types include:</p> <ul> <li>string</li> <li>integer</li> <li>float</li> <li>boolean</li> <li>enum</li> <li>asset</li> </ul>"},{"location":"input/#enum","title":"<code>enum</code>","text":"<p>The <code>type=enum</code> field has an additional mandatory <code>values</code> field, which lists all allowed enum values. Note that enums should be validated by a parsing library or a library calling the tools. For the tools, enums parameters are treated like  strings as soon as read from a <code>input.json</code> file.</p> <p>Example</p> <pre><code>tool:\n  foobar:\n    parameters:\n      my_enum:\n        type: enum\n        values:\n          - option 1\n          - option 2\n          - option 3\n</code></pre>"},{"location":"input/#asset","title":"<code>asset</code>","text":"<p>The <code>type=asset</code> can be used to specify paths to files or entire folders that are copied unchanged to the <code>/in/</code> path of the tool container and thus made available to the tool for further processing. The parsing library never attempts to load and process these files, therefore assets are available as-is in the container. Assets are neither Data nor parameters, but their dynamic nature might influence the tool execution. Hence, they are added as input to the tool.</p>"},{"location":"input/#description","title":"<code>description</code>","text":"<p>The <code>description</code> is a multiline comment to describe the purpose of the parameter. For the <code>description</code>, Markdown is allowed, although tool-frameworks are not required to parse it. Descriptions are optional and can be omitted.</p> <p>A mutltiline comment in YAML can be specified like:</p> <pre><code>description: | \n    This is the first line\n    This is the second line\n</code></pre>"},{"location":"input/#array","title":"<code>array</code>","text":"<p>The <code>array</code> field takes a single boolean value and defaults to <code>array=false</code>. If set to <code>array=true</code> the <code>Parameter</code> is an array of the specified <code>type</code>. The array field cannot be combined with the <code>type=enum</code> field.</p>"},{"location":"input/#min","title":"<code>min</code>","text":"<p>Minimum value for constraining the value range. The <code>min</code> field is only valid for <code>type=integer</code> and <code>type=float</code>. Setting a minimum value is optional and can be omitted. Note that if a <code>max</code> value is additionally specified for the parameter, <code>min</code> must be lower than <code>max</code>.</p>"},{"location":"input/#max","title":"<code>max</code>","text":"<p>Maximum value for constraining the value range. The <code>max</code> field is only valid for <code>type=integer</code> and <code>type=float</code>. Setting a maximum value is optional and can be omitted. Note that if a <code>min</code> value is additionally specified for the parameter, <code>max</code> must be higher than <code>min</code>.</p>"},{"location":"input/#optional","title":"<code>optional</code>","text":"<p>Boolean field which defaults to <code>false</code>. If set to <code>optional=true</code>, the parameter is not required by the tool. This implies, that the tool implementation can handle a <code>input.json</code> in which the <code>Parameter</code> is entirely missing.</p>"},{"location":"input/#default","title":"<code>default</code>","text":"<p>The <code>default</code> field is of the same data type as the <code>Parameter</code> itself. If a default value is set, the tool-framework is required to inject this parameter into the <code>input.json</code>, as the tool will treat the default like any other non-optional parameter. Note, that default parameters are only parsed if they are not set as <code>optional=true</code>.</p>"},{"location":"input/#data-file-specification","title":"Data: File specification","text":"<p>All input <code>Data</code> is described in a data block in the <code>/src/tool.yml</code> file. All sets of input data are collected as the optional <code>tools.&lt;tool_name&gt;.data</code> block. The simplest declaration of input data is to list all available data files in a single, top-level list:</p> <pre><code>tools:\n  foobar:\n    parameters:\n      [...]\n    data:\n      - foo_data\n      - foo_data2\n</code></pre> <p>If any of the dataset sources requires a more detailed configuration, objects  can be specifies as well:</p> <pre><code>tools:\n  foobar:\n    parameters:\n      [...]\n    data:\n      foo_data:\n        description: Our first dataset with foo properties\n      foo_data2:\n        description: Our second dataset with foo2 properties\n</code></pre> <p>Refer to the section below to learn about the fields for <code>Data</code>.</p>"},{"location":"input/#fields_1","title":"Fields","text":"<p>The following section defines all fields of a <code>Data</code> entity.</p>"},{"location":"input/#description_1","title":"<code>description</code>","text":"<p>The <code>description</code> is a single- or multiline comment to describe the input data. For the <code>description</code> Markdown is allowed, although tool-frameworks are not required to parse it. Descriptions are optional and can be omitted, but it is highly recommended to  add descriptions to all required data inputs.</p> <p>A multiline comment in YAML can be specified like:</p> <pre><code>description: | \n    This is the first line\n    This is the second line\n</code></pre>"},{"location":"input/#example","title":"<code>example</code>","text":"<p>The <code>example</code> field is optional and can be used to reference a sample dataset for the given input, within the container. Data examples are a prime source  for your users to understand how inputs should look like and be formatted.</p> <pre><code>example: /in/input_name.csv\n</code></pre> <p>It is considered good practice to add example data and example parameterizations to the <code>/in/</code> folder. At inspection time, when a client application reads the  <code>tool.yml</code>, this client can also access the examples in the <code>/in/</code> folder. At runtime, as the client application mounts data and parameterizations into the container at <code>/in/</code>, the examples are non-existent in the container and cannot  accidentally pollute the runtime container.</p>"},{"location":"input/#extension","title":"<code>extension</code>","text":"<p>The <code>extension</code> field is optional and can be used to limit the permitted file  extensions for a data input. Allowed is a single string input or a list of strings. By convention, the point <code>.</code> should be included into the <code>extension</code> as well.</p> <pre><code>extension: .csv\n</code></pre> <pre><code>extension:\n  - .dat\n  - .TXT\n</code></pre> <p>Note that the <code>extension</code> field is case insensitive. </p>"},{"location":"input/#example_1","title":"Example","text":"<pre><code>tools:\n  foobar:\n    title: Dummy Tools\n    parameters:\n      foo_int:\n        type: integer\n        min: 0\n        max: 10\n        description: An integer between 0 and 10\n      foo_str:\n        type: string\n        default: My default string\n      foo_option:\n        type: enum\n        values:\n          - option 1\n          - option 2\n          - option 3\n      foo_array:\n        type: float\n        array: true\n        optional: true\n        description: An optional array of floats\n    data:\n      foo_csv_data:\n        description: |\n          This is a CSV file that should contain valid input. We do currently\n          not specify, what that exactly means.\n      foo_nc_data:\n        description: CF-netCDF 1.8 conform climate model output.    \n</code></pre>"},{"location":"tool/","title":"Tool definition","text":""},{"location":"tool/#description","title":"Description","text":"<p>We define a <code>Tool</code> to be an executable script/program inside a docker container. In order to be recognized as a <code>Tool</code>, the container has to meet a set of requirements, which are described here</p>"},{"location":"tool/#file-specification","title":"File specification","text":"<p>The specification is defined in a single YAML file, located at <code>/src/tool.yml</code>. This file holds specifications about the container image itself.  At the current state, only one field is defined and supported: <code>tools</code>. The <code>tools</code> field contains a named struct with <code>Tool</code> specifications indexed by the <code>Tool</code> name.</p> <p>The file content of the <code>tool.yml</code> has to at least include:</p> <pre><code>tools:\n  toolname: Tool \n\n  [...] \n</code></pre>"},{"location":"tool/#fields","title":"Fields","text":"<p>The following section will define all mandatory and optional fields of a <code>Tool</code> entity.</p>"},{"location":"tool/#title","title":"<code>title</code>","text":"<p>The title is mandatory and should contain a descriptive, short single line title to identify a tool.  It is recommended to use titles with less than 64 characters.</p>"},{"location":"tool/#description_1","title":"<code>description</code>","text":"<p>Multiline comment to describe the purpose of a tool and needed information to call a tool properly, as well as specificities of implementation which might be relevant for the user. The description can be supplied as Markdown, although tool-frameworks are not required to parse  Markdown. Thus a Markdown description might be rendered as plain text.</p> <p>A multiline descriptions in YAML can be specified like:</p> <pre><code>description: | \n  This is the first line.\n  This is the second line.\n</code></pre>"},{"location":"tool/#parameters","title":"<code>parameters</code>","text":"<p>Parameters for tools are also an Entity defined in the specification.  The parameters field hold a struct of <code>Parameter</code> instances indexed by the parameter name. An example can be found in the Example section below or on the Parameters page.</p>"},{"location":"tool/#data","title":"<code>data</code>","text":"<p>Input data for a tool is defined separately from the  parameters in an additional section of <code>tool.yml</code>. Just like for the parameters, the input data of a tool is indexed by their names. In case no further configuration is needed, data may be supplied in a single list of dataset names. Data has to be provided as files, which may be nested in sub-folders of <code>/in/</code>.</p>"},{"location":"tool/#example","title":"Example","text":"<p>The following YAML file contains a sample tool specification, similar to the dummy specifications found in the different tool template containers.</p> <pre><code>tools:\n  foobar:\n    title: Foo Bar\n    description: A dummy tool to exemplify the YAML file\n    version: 0.1\n    parameters:\n      foo_int: \n        type: integer\n      foo_float:\n        type: float\n      foo_string:\n        type: string\n      foo_enum:\n        type: enum\n        values:\n          - foo\n          - bar\n          - baz\n      foo_array:\n        type: integer\n        array: true\n    data:\n      - foo_csv:\n      - foo_nc:\n</code></pre>"}]}